# Study time series

In this section we want study the time series of precipitation in the
Central Amazon Basin.

We use the location that is also used in the Ciemer et al paper.

```{r}
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(raster)
```

```{r}
source("../code/R/helper-functions.R")
```

```{r, include=FALSE}
world <- ne_countries(scale = "medium", returnclass = "sf")
class(world)
theme_set(theme_bw())
```

```{r, include=FALSE}
ggplot(data = world) +
  geom_sf() +
  xlab("Longitude") + ylab("Latitude") +
  ggtitle("World map", subtitle = paste0("(", length(unique(world$name)), " countries)"))
```

Time frame: 1980 to 2016

### Overview
```{r, include=FALSE}
# helpers
plot_summary <- function(summary) {
  df <- base::as.data.frame(cbind(coordinates(summary), summary@data@values))
  colnames(df) <- c("Longitude","Latitude", "val")
  plt <- ggplot(data = df, aes(x = Longitude, y = Latitude, fill = val)) +
    geom_raster(interpolate = FALSE) +
    scale_fill_gradient2(low = "red", high = "blue", midpoint = mean(df$val))
  plt
}

plot_trends <- function(data, trends) {
  df <- base::as.data.frame(cbind(coordinates(data), trends))
  colnames(df) <- c("Longitude","Latitude", "val")
  plt <- ggplot(data = df, aes(x = Longitude, y = Latitude, fill = val)) +
    geom_raster(interpolate = FALSE) +
    scale_fill_gradient2(low = "red", high = "blue", midpoint = mean(df$val))
  plt
}
```


Below the frame of the Central Amazon Basin

```{r, echo=FALSE}
ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-100,-20), ylim = c(40,-40), expand = TRUE) +   geom_rect(xmin = -70, xmax = -55, ymin = -10, ymax = 0,
                                                                              fill = NA, colour = "black", size = 1.5)
```

```{r}
precip <- brick("../../data/interim/drought/chirps_setreftime.nc")
precip <- raster::aggregate(precip, fact = 10)
```

#### Plot mean
```{r}
r_mean <- calc(precip, mean)
#plot(r_mean)
plot_summary(r_mean) + ggtitle("Mean of precipitation for each location")
```

#### Plot density of means
```{r}
df_mean <- data.frame(means = values(r_mean))
ggplot(df_mean, aes(x = means)) + geom_density() + ggtitle("Density of means computed on each location")
```

As we can see most locations have a mean precipitation of around 200 mm/month, over
the whole time series. Regionally in the "upper left" corner of the Amazon Basin,
mean precipitation is higher or equal to the mean. The reference
point for "higher" is the mean of the location means. This region seems to be more
or less spatially consistent. The rest of the region with lower mean precipitation
has also some small areas where precipitation is again a little bit higher. 
For example in the upper right corner and on the bottom, right of the middle.


#### Plot sd
```{r}
r_sd <- calc(precip, sd)
#plot(r_sd)
plot_summary(r_sd) + ggtitle("SD of precipitation for each location")
```

#### Plot density of sd
```{r}
df_sd <- data.frame(sd = values(r_sd))
ggplot(df_sd, aes(x = sd)) + geom_density()
```

For the standard deviation we also see regional patterns. These patterns overlap
with the regions of the mean but their magnitude is flipped. Meaning,
in the upper left where we observe larger mean values we generally observe lower
standard deviation and in the lower and upper right corners, higher standard 
deviations.

Question: There are obviously regional differences in magnitude of mean
and standard deviations. Should we therefore NOT normalise the time series, prior
to clustering? Mean and SD contain information and the variables are all measured 
on the same scale. (Consideration: seasonality might play a role, meaning
that the values of different months come a different distribution)

#### Plot trends
```{r, include=FALSE}
get_trend <- function(vec) {
  b <- seq(length(vec))
  trend <- lm(vec ~ b)$coefficients[2]
  return(trend)
}
```


```{r}
trends <- apply(getValues(precip), 1, get_trend)
plot_trends(precip, trends)
df_trends <- data.frame(tr = trends)
ggplot(df_trends, aes(x = tr)) + geom_density()
```

Many regions dont have a trend and trends in general seem to be quite small.
We can identify some regions with similar up or downward trends.
We also computed plots for the deseasonalised data but it looked almost the same

Plot means and sd for each month respectively
```{r,include=FALSE}
create_ind_mat <- function(precip_data) {
  ind_mat <- matrix(NA, nrow = 12, ncol = nlayers(precip_data)/12)
  for(i in 1:12) {
    ind_mat[i,] <- seq(i, ncol(ind_mat), 12)
  }
  return(ind_mat)
}

mon_plots <- function(precip_data) {
  ind_mat <- create_ind_mat(precip_data)
  plot_list_m <- list()
  plot_list_sd <- list()
  pvals <- getValues(precip_data)
  for(i in 1:nrow(ind_mat)) {
    mon <- subset(precip_data, ind_mat[i,])
    mon_means <- calc(mon, mean)
    mon_sd <- calc(mon, sd)
    m_plot <- plot_summary(mon_means) + ggtitle(paste("Means for month", i))
    sd_plot <- plot_summary(mon_sd)  + ggtitle(paste("SD for month", i))
    plot_list_m[[i]] <- m_plot
    plot_list_sd[[i]] <- sd_plot
  }
  return(list(plot_list_m,plot_list_sd))
}
```


```{r}
plt_list <- mon_plots(precip)
```



#### Means per month {.tabset .tabset-fade .tabset-pills}

##### January

```{r}
plt_list[[1]][1]
```

##### February

```{r}
plt_list[[1]][2]
```

##### March

```{r}
plt_list[[1]][3]
```

##### April

```{r}
plt_list[[1]][4]
```

##### May

```{r}
plt_list[[1]][5]
```

##### June

```{r}
plt_list[[1]][6]
```


##### July

```{r}
plt_list[[1]][7]
```

##### August

```{r}
plt_list[[1]][8]
```

##### September

```{r}
plt_list[[1]][9]
```

##### October

```{r}
plt_list[[1]][10]
```

##### November

```{r}
plt_list[[1]][11]
```

##### December

```{r}
plt_list[[1]][12]
```

#### {-}

We see spatial patterns of the mean evolving over time.
For example: From May until August there is a spatial separation in 
two parts that dissolves in september.
As expected there is a large seasonal component regarding the means.


#### SD per month {.tabset .tabset-fade .tabset-pills}

##### January

```{r}
plt_list[[2]][1]
```

##### February

```{r}
plt_list[[2]][2]
```

##### March

```{r}
plt_list[[2]][3]
```

##### April

```{r}
plt_list[[2]][4]
```

##### May

```{r}
plt_list[[2]][5]
```

##### June

```{r}
plt_list[[2]][6]
```


##### July

```{r}
plt_list[[2]][7]
```

##### August

```{r}
plt_list[[2]][8]
```

##### September

```{r}
plt_list[[2]][9]
```

##### October

```{r}
plt_list[[2]][10]
```

##### November

```{r}
plt_list[[2]][11]
```

##### December

```{r}
plt_list[[2]][12]
```

### {-}

For the standard deviation we see as well large differences in values 
during different months of the year.

Do we get stationary time series when we only take each january or february?
Check for stationarity of the different time series?


#### Open: summarise CAB for each month (mean Jan, Feb, etc.)
### Clustering

#### Kmeans clustering (vanilla) {.tabset .tabset-face .tabset-pills}

```{r, include=FALSE}
plot_kmeans <- function(data, kmeans_solution) {
  df <- base::as.data.frame(cbind(coordinates(data), kmeans_solution$cluster))
  colnames(df) <- c("Longitude","Latitude", "Cluster")
  df$Cluster <- factor(df$Cluster)
  plt <- ggplot(data = df, aes(x = Longitude, y = Latitude, fill = Cluster)) +
    annotation_map(map_data("world")) +
    geom_raster(interpolate = TRUE)
  plt
}
```

```{r, include=FALSE}
s <- 1:10

get_kmeans <- function(data, s) {
  if (!is.matrix(data)) data <- getValues(data)
  res_list <- list()
  j <- 1
  for (i in s) {
    res_list[[j]] <- kmeans(data, i, nstart = 10)
    j <- j+1
  }
  return(res_list)
}

km_list <- get_kmeans(precip, s)
```

```{r}
set.seed(123)
km_list <- get_kmeans(precip, s)
```


##### K = 1
```{r}
plot_kmeans(precip, km_list[[1]])
```

##### K = 2

```{r}
plot_kmeans(precip, km_list[[2]])
```

##### K = 3

```{r}
plot_kmeans(precip, km_list[[3]])
```

##### K = 4

```{r}
plot_kmeans(precip, km_list[[4]])
```

##### K = 5

```{r}
plot_kmeans(precip, km_list[[5]])
```

##### K = 6

```{r}
plot_kmeans(precip, km_list[[6]])
```

##### K = 7

```{r}
plot_kmeans(precip, km_list[[7]])
```

##### K = 8

```{r}
plot_kmeans(precip, km_list[[8]])
```

##### K = 9

```{r}
plot_kmeans(precip, km_list[[9]])
```

##### K = 10

```{r}
plot_kmeans(precip, km_list[[10]])
```

### {-}

We can see that clusters form spatial patterns that become smaller and get divided
with a larger number of cluster. For example for K=4 cluster 4 stays consistent until
including K=6 and gets divided at K=7

#### Evaluate kmeans vanilla

OPEN: 
(silhouette)
(wss)


with gap statistic
```{r}
set.seed(123)

#gap_stat <- cluster::clusGap(getValues(precip), FUN = kmeans, nstart = 10,
#                             K.max = 10, B = 50)
#saveRDS(gap_stat, file = "../../results/gap_stat_k10.RDS")
gap_stat <- readRDS( "../../results/gap_stat_k10.RDS")
gap_plot <- factoextra::fviz_gap_stat(gap_stat)
gap_plot
```


```{r}
#gap_stat_large <- cluster::clusGap(getValues(precip), FUN = kmeans, nstart = 10,
#                                   K.max = 100, B = 50)
#saveRDS(gap_stat_large, file = "../../results/gap_stat_k100.RDS")
gap_stat_large <- readRDS("../../results/gap_stat_k100.RDS")
gap_large_plot <- factoextra::fviz_gap_stat(gap_stat_large)
gap_large_plot
# NOTE this visualisation method chooses first local max
```
```{r, include=FALSE}
# # get optimal k by hand
# tab <- as.matrix(gap_stat_large$Tab)
# head(tab)
# # this is gap(k), we drop the last observation because it has no comparison
# g <- tab[-nrow(tab),"gap"]
# # this is the difference we compare g(k) to, g(k+1) - s(k+1)
# d <- tab[-1,"gap"] - tab[-1,"SE.sim"]
# g >= d
```


```{r}
# print(gap_stat_large, method = "firstmax")
# chooses 41 as cluster
# print(gap_stat_large, method = "Tibs2001SEmax")
# chooses 26 as optimal cluster
```

For a maximum of 10 Clusters we dont reach a local maximum that is smaller than 10,
so the number of optimal clusters is the same as the maximum we search for.
When we increase to 100, the optimal number of clusters depends also on the metric.
For example searching for the first local maximum gives K=41, while 
the criteria suggested by Tibshirani gives 26: Choose the first K which gives
a gap statist that satisfies $$G(K) \geq G(K+1) - s_{K+1}.$$ Meaning the first
K that gives a gap statistic that is larger than the gap statistic of K+1 minus
the respective standard deviation of K+1`s simulated gap statistics.



#### Kmeans clustering after computing correlation

```{r}
values_precip <- getValues(precip)
values_precip <- t(values_precip)
cor_precip <- cor(values_precip)
dim(cor_precip)
```
```{r}
km_cor <- get_kmeans(cor_precip, s)
```


```{r}
plot_kmeans(precip, km_cor[[1]])
l <- list()
for(i in 1:10) {
  l[[i]] <- plot_kmeans(precip, km_cor[[i]])
}
l[10]
```

```{r}
km_cor[[1]]$tot.withinss
totwss <- c()
for(i in 1:10) {
  totwss[i] <- km_cor[[i]]$tot.withinss
}

plot(1:10,totwss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```

```{r}
gap_cor <- cluster::clusGap(cor_precip, FUN=kmeans, nstart = 10, K.max=10,B=50)
```
```{r}
plt <- factoextra::fviz_gap_stat(gap_cor)
```

```{r}
plot_kmeans(precip, km_cor[[4]])
```

#### OPEN pam with corr

```{r}
diss_mat <- 1 - cor_precip
```


#### hierarchical clustering

?if we scale do we need to scale with respect to month, say january etc
?compare the means of the different months with each other
?check if al means come from the same distribution?

##### agglomerative
on one link firstly

```{r}
?dist
cl <- hclust(stats::dist(getValues(precip)))
plot(cl)

```
```{r}

```



##### divisive
on onw link firstly